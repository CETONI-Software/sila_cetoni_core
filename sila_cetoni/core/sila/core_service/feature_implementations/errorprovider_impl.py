# Generated by sila2.code_generator; sila2.__version__: 0.10.1
from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import TYPE_CHECKING, List

from sila2.server import MetadataDict

from sila_cetoni.utils import PropertyUpdater, not_equal

from ..generated.errorprovider import ClearAllErrors_Responses
from ..generated.errorprovider import Error as ErrorType
from ..generated.errorprovider import ErrorProviderBase
from ..generated.errorprovider import SeverityLevel as SeverityLevelType

if TYPE_CHECKING:
    from ..server import Server


class SeverityLevel(Enum):
    INFO = "INFO"
    WARNING = "WARNING"
    CRITICAL = "CRITICAL"
    FATAL = "FATAL"


@dataclass
class Error:
    level: SeverityLevel
    description: str
    timestamp: datetime = field(default_factory=datetime.now)

    def __level_to_code(self) -> int:
        if self.level == SeverityLevel.INFO:
            return 0
        if self.level == SeverityLevel.WARNING:
            return 1
        if self.level == SeverityLevel.CRITICAL:
            return 2
        if self.level == SeverityLevel.FATAL:
            return 3

    def to_error_type(self) -> ErrorType:
        return ErrorType(
            Timestamp=self.timestamp,
            Level=SeverityLevelType(Code=self.__level_to_code(), Name=self.level.value),
            Description=self.description,
        )

    def __str__(self) -> str:
        return f"{self.__class__.__name__}({self.timestamp!s}, {self.level.value!r}, {self.description!r})"


class ErrorProviderImpl(ErrorProviderBase):
    __errors: List[Error]

    def __init__(self, parent_server: Server) -> None:
        super().__init__(parent_server=parent_server)

        self.run_periodically(
            PropertyUpdater(
                lambda: self.__errors, not_equal, lambda errors: self.update_Errors([e.to_error_type() for e in errors])
            )
        )
        self.run_periodically(
            PropertyUpdater(lambda: self.__errors[-1], not_equal, lambda e: self.update_LastError(e.to_error_type()))
        )

    def ClearAllErrors(self, *, metadata: MetadataDict) -> ClearAllErrors_Responses:
        self.__errors.clear()

    # interface for other feature implementations
    def add_error(self, error: Error) -> None:
        """
        Adds an error to the list of errors
        """
        self.__errors.append(error)


# ----------------------------------------------------------------------------
# test
if __name__ == "__main__":
    from datetime import timedelta

    now = datetime.now()
    e1 = Error(SeverityLevel.INFO, "test 1", now)
    e2 = Error(SeverityLevel.INFO, "test 1", now)
    e3 = Error(SeverityLevel.WARNING, "test 1", now)
    e4 = Error(SeverityLevel.INFO, "test 2", now)
    e5 = Error(SeverityLevel.INFO, "test 1", now + timedelta(seconds=1))

    print(e1)
    print(e2)
    print(e3)
    print(e4)
    print(e5)
    print(Error(SeverityLevel.CRITICAL, "test"))
    import time
    time.sleep(2)
    print(Error(SeverityLevel.FATAL, "test"))

    assert e1 == e2

    assert e1 != e3
    assert e2 != e3

    assert e1 != e4
    assert e2 != e4
    assert e3 != e4

    assert e1 != e5
    assert e2 != e5
    assert e3 != e5
    assert e4 != e5
