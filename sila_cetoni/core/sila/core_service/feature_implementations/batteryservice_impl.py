# Generated by sila2.code_generator; sila2.__version__: 0.8.0
from __future__ import annotations

import logging
import math
import time
from concurrent.futures import Executor
from threading import Event
from typing import Any, Dict

from sila2.framework import CommandExecutionInfo, CommandExecutionStatus
from sila2.server import MetadataDict, ObservableCommandInstance, SilaServer

from sila_cetoni.application.system import ApplicationSystem

from ....device_drivers import BatteryInterface
from ..generated.batteryservice import BatteryServiceBase, PerformBatteryReplacement_Responses

logger = logging.getLogger(__name__)


class BatteryServiceImpl(BatteryServiceBase):
    __battery: BatteryInterface
    __system: ApplicationSystem
    __stop_event: Event

    def __init__(self, server: SilaServer, battery: BatteryInterface, executor: Executor):
        super().__init__(server)
        self.__battery = battery
        self.__system = ApplicationSystem()
        self.__stop_event = Event()

        def update_is_connected(stop_event: Event):
            new_is_connected = is_connected = self.__battery.is_connected
            while not stop_event.is_set():
                new_is_connected = self.__battery.is_connected
                if new_is_connected != is_connected:
                    is_connected = new_is_connected
                    self.update_IsConnected(is_connected)
                time.sleep(0.1)

        def update_voltage(stop_event: Event):
            new_voltage = voltage = self.__battery.voltage if self.__system.state.is_operational() else 0
            while not stop_event.is_set():
                new_voltage = self.__battery.voltage if self.__system.state.is_operational() else 0
                if not math.isclose(new_voltage, voltage, abs_tol=1.0e-3):
                    voltage = new_voltage
                    self.update_BatteryVoltage(voltage)
                time.sleep(0.1)

        def update_temperature(stop_event: Event):
            new_temperature = temperature = self.__battery.temperature if self.__system.state.is_operational() else 0
            while not stop_event.is_set():
                new_temperature = self.__battery.temperature if self.__system.state.is_operational() else 0
                if not math.isclose(new_temperature, temperature, abs_tol=1.0e-3):
                    temperature = new_temperature
                    self.update_BatteryTemperature(temperature)
                time.sleep(0.1)

        def update_locking_pin_state(stop_event: Event):
            new_state = state = self.__battery.locking_pin_state
            while not stop_event.is_set():
                new_state = self.__battery.locking_pin_state
                if new_state != state:
                    state = new_state
                    self.update_LockingPinState(state)
                time.sleep(0.1)

        # initial values
        self.update_IsConnected(self.__battery.is_connected)
        self.update_BatteryVoltage(self.__battery.voltage)
        self.update_BatteryTemperature(self.__battery.temperature)
        self.update_LockingPinState(self.__battery.locking_pin_state)

        executor.submit(update_is_connected, self.__stop_event)
        executor.submit(update_voltage, self.__stop_event)
        executor.submit(update_temperature, self.__stop_event)
        executor.submit(update_locking_pin_state, self.__stop_event)

    def PerformBatteryReplacement(
        self, *, metadata: MetadataDict, instance: ObservableCommandInstance
    ) -> PerformBatteryReplacement_Responses:
        for (progress, status, error) in self.__battery.replace_battery():
            logger.info(f"{progress}: {status} ({error})")
            instance.progress = min(progress, 100)
            if instance.progress < 100:
                instance.status = CommandExecutionStatus.running
            else:
                instance.status = (
                    CommandExecutionStatus.finishedWithError if error else CommandExecutionStatus.finishedSuccessfully
                )

    def stop(self) -> None:
        super().stop()
        self.__stop_event.set()
