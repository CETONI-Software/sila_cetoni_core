# Generated by sila2.code_generator; sila2.__version__: 0.8.0
from __future__ import annotations
import math
import time
from concurrent.futures import Executor
from threading import Event
from typing import Any, Dict

from sila2.server import SilaServer, MetadataDict, ObservableCommandInstance

from sila_cetoni.application.system import ApplicationSystem
from ....device_drivers import BatteryInterface

from ..generated.batteryservice import BatteryServiceBase, PerformBatteryReplacement_Responses


class BatteryServiceImpl(BatteryServiceBase):
    __battery: BatteryInterface
    __system: ApplicationSystem
    __stop_event: Event

    def __init__(self, server: SilaServer, battery: BatteryInterface, executor: Executor):
        super().__init__(server)
        self.__battery = battery
        self.__system = ApplicationSystem()
        self.__stop_event = Event()

        def update_voltage(stop_event: Event):
            new_voltage = voltage = self.__battery.voltage if self.__system.state.is_operational() else 0
            while not stop_event.is_set():
                new_voltage = self.__battery.voltage if self.__system.state.is_operational() else 0
                if not math.isclose(new_voltage, voltage, abs_tol=1.0e-3):
                    voltage = new_voltage
                    self.update_BatteryVoltage(voltage)
                time.sleep(0.1)

        # initial value
        self.update_BatteryVoltage(self.__battery.voltage)

        executor.submit(update_voltage, self.__stop_event)

    def PerformBatteryReplacement(
        self, *, metadata: MetadataDict, instance: ObservableCommandInstance
    ) -> PerformBatteryReplacement_Responses:
        # TODO provide some simple progress info (e.g. 25% after unlocking, 50% after removing, 75% after inserting, 100% after locking)
        self.__battery.replace_battery()

    def stop(self) -> None:
        self.__stop_event.set()
